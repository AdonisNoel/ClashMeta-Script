<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>节点转 Clash.Meta 配置</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #f4f6f8;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 5px;
            resize: vertical;
        }

        .controls {
            margin: 15px 0;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: .2s;
        }

        button:hover {
            background: #45a049;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        pre {
            white-space: pre-wrap;
            word-break: break-word;
            background: #272822;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            max-height: 500px;
            overflow-y: auto;
        }

        @media (max-width:600px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>节点转 Clash.Meta 配置</h1>
        <textarea id="input" placeholder="在这里粘贴节点链接，每行一个"></textarea>
        <div class="controls">
            <label class="checkbox-label">
                <input type="checkbox" id="fullConfig" checked>
                生成完整配置（含规则）
            </label>
            <button onclick="convert()">生成</button>
            <button onclick="copyOutput()">复制</button>
            <button onclick="downloadYaml()">下载</button>
        </div>
        <pre id="output"></pre>
    </div>

    <script>
        // ========== 工具函数 ==========
        function safeB64Decode(str) {
            try {
                str = str.replace(/-/g, '+').replace(/_/g, '/');
                const pad = str.length % 4;
                if (pad) str += '='.repeat(4 - pad);
                return decodeURIComponent(escape(atob(str)));
            } catch { return ''; }
        }

        // ========== 协议解析 ==========
        function parseVless(url) {
            const u = new URL(url);
            const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`;
            const q = u.searchParams;
            const node = {
                name, type: "vless", server: u.hostname, port: parseInt(u.port),
                uuid: u.username, udp: true,
                network: q.get("type") || "tcp",
                servername: q.get("sni") || q.get("host") || u.hostname,
            };
            const security = q.get("security");
            if (security === "reality") {
                node.tls = true;
                node["client-fingerprint"] = q.get("fp") || "chrome";
                node["reality-opts"] = { "public-key": q.get("pbk") || "", "short-id": q.get("sid") || "" };
                node._subtype = "REALITY";
            } else if (security === "tls") {
                node.tls = true;
                node._subtype = "TLS";
            } else {
                node.tls = false;
            }
            if (node.network === "ws") node["ws-opts"] = { path: decodeURIComponent(q.get("path") || "/"), headers: { Host: q.get("host") || u.hostname } };
            if (node.network === "grpc") node["grpc-opts"] = { "grpc-service-name": q.get("serviceName") || "" };
            return node;
        }
        function parseVmess(url) { const data = JSON.parse(safeB64Decode(url.slice(8))); const node = { name: data.ps || `${data.add}:${data.port}`, type: "vmess", server: data.add, port: parseInt(data.port), uuid: data.id, alterId: parseInt(data.aid || 0), cipher: data.scy || "auto", udp: true, tls: data.tls === "tls", network: data.net || "tcp" }; if (node.network === "ws") node["ws-opts"] = { path: data.path || "", headers: { Host: data.host || "" } }; return node; }
        function parseSS(url) {
            try {
                const u = new URL(url);
                const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`;
                let userInfo = u.username;
                if (u.password) userInfo = `${u.username}:${u.password}`;
                const decodedUserInfo = safeB64Decode(userInfo);
                const firstColonIndex = decodedUserInfo.indexOf(':');
                if (firstColonIndex === -1) return null;
                const method = decodedUserInfo.substring(0, firstColonIndex);
                const password = decodedUserInfo.substring(firstColonIndex + 1);
                const node = { name, type: "ss", server: u.hostname, port: parseInt(u.port), cipher: method, password: password, udp: true };
                const plugin = u.searchParams.get("plugin");
                if (plugin) {
                    const decodedPlugin = decodeURIComponent(plugin);
                    if (decodedPlugin.includes('v2ray-plugin')) {
                        node.plugin = 'v2ray-plugin';
                        const pluginParts = decodedPlugin.split(';');
                        const opts = {};
                        pluginParts.forEach(part => {
                            const [key, value] = part.split('=');
                            if (key === 'obfs' && value === 'websocket') opts.mode = 'websocket';
                            else if (key === 'obfs-host' || key === 'host') opts.host = value;
                            else if (key === 'path') opts.path = value;
                            else if (key === 'tls') opts.tls = true;
                        });
                        if (opts.mode === 'websocket') {
                            node['plugin-opts'] = {
                                mode: 'websocket', tls: opts.tls || false,
                                host: opts.host || u.hostname, path: opts.path || "/",
                                skip_cert_verify: opts.tls || false
                            };
                        } else { node['plugin-opts'] = opts; }
                    }
                }
                return node;
            } catch (e) { console.error("Failed to parse SS URL:", url, e); return null; }
        }
        function parseTrojan(url) {
            const u = new URL(url);
            const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`;
            const q = u.searchParams;
            const node = {
                name, type: "trojan", server: u.hostname, port: parseInt(u.port),
                password: u.username, udp: true, sni: q.get("sni") || u.hostname,
            };
            const security = q.get("security");
            if (security === "reality") {
                node["client-fingerprint"] = q.get("fp") || "chrome";
                node["reality-opts"] = { "public-key": q.get("pbk") || "", "short-id": q.get("sid") || "" };
                node._subtype = "REALITY";
            } else {
                node._subtype = "TLS";
            }
            return node;
        }
        function parseHysteria(url) { const u = new URL(url); const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`; return { name, type: "hysteria", server: u.hostname, port: parseInt(u.port), auth_str: u.username || "", alpn: u.searchParams.get("alpn")?.split(',') || [], protocol: u.searchParams.get("protocol") || "udp", up: u.searchParams.get("up") || "", down: u.searchParams.get("down") || "", sni: u.searchParams.get("sni") || u.hostname, skip_cert_verify: u.searchParams.get("insecure") === "1" }; }
        function parseHysteria2(url) { const u = new URL(url); const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`; return { name, type: "hysteria2", server: u.hostname, port: parseInt(u.port), password: u.username || "", alpn: u.searchParams.get("alpn")?.split(',') || [], sni: u.searchParams.get("sni") || u.hostname, skip_cert_verify: u.searchParams.get("insecure") === "1" }; }
        function parseTuic(url) { const u = new URL(url); const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`; return { name, type: "tuic", server: u.hostname, port: parseInt(u.port), uuid: u.username, password: u.searchParams.get("password") || "", alpn: u.searchParams.get("alpn")?.split(',') || [], sni: u.searchParams.get("sni") || u.hostname, skip_cert_verify: u.searchParams.get("insecure") === "1" }; }
        function parseWireGuard(url) { const u = new URL(url); const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`; return { name, type: "wireguard", server: u.hostname, port: parseInt(u.port), ip: u.searchParams.get("ip") || "", private_key: u.searchParams.get("private_key") || "", public_key: u.searchParams.get("public_key") || "", allowed_ips: u.searchParams.get("allowed_ips")?.split(',') || ["0.0.0.0/0", "::/0"], mtu: parseInt(u.searchParams.get("mtu") || "0"), dns: u.searchParams.get("dns")?.split(',') || [] }; }
        function parseSocks(url) { const u = new URL(url); const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`; return { name, type: "socks5", server: u.hostname, port: parseInt(u.port), username: u.username || undefined, password: u.password || undefined }; }
        function parseHttpProxy(url) { const u = new URL(url); const name = decodeURIComponent(u.hash.replace('#', '')) || `${u.hostname}:${u.port}`; return { name, type: "http", server: u.hostname, port: parseInt(u.port), username: u.username || undefined, password: u.password || undefined }; }

        // ========== 统一解析入口 ==========
        function parseLink(url) {
            let node = null;
            try {
                if (url.startsWith("ss://")) node = parseSS(url);
                else if (url.startsWith("vless://")) node = parseVless(url);
                else if (url.startsWith("vmess://")) node = parseVmess(url);
                else if (url.startsWith("trojan://")) node = parseTrojan(url);
                else if (url.startsWith("hysteria://")) node = parseHysteria(url);
                else if (url.startsWith("hysteria2://")) node = parseHysteria2(url);
                else if (url.startsWith("tuic://")) node = parseTuic(url);
                else if (url.startsWith("wireguard://") || url.startsWith("wg://")) node = parseWireGuard(url);
                else if (url.startsWith("socks5://")) node = parseSocks(url);
                else if (url.startsWith("http://") || url.startsWith("https://")) node = parseHttpProxy(url);
            } catch (e) {
                console.error(`解析失败 (Failed to parse): ${url.substring(0, 50)}...`, e);
            }

            if (node) {
                Object.keys(node).forEach(key => (node[key] === undefined || node[key] === null || (typeof node[key] === 'string' && node[key] === '')) && delete node[key]);
                let protocol = node.type.toUpperCase();
                if (node._subtype) {
                    protocol += `_${node._subtype}`;
                    delete node._subtype;
                }
                const originalName = node.name;
                const truncatedName = originalName.length > 20 ? originalName.substring(0, 20) + '...' : originalName;
                node.name = `${protocol}-${truncatedName}`;
            }
            return node;
        }

        // ========== YAML输出及页面交互 ==========
        function proxyToExpandedYaml(p) {
            const lines = [];
            const mainIndent = '  ';
            const subIndent = '    ';
            lines.push(`${mainIndent}- name: ${JSON.stringify(p.name)}`);
            for (const key in p) {
                if (key === 'name') continue;
                const value = p[key];
                if (value === undefined || value === null) continue;
                if (Array.isArray(value)) {
                    if (value.length === 0) continue;
                    lines.push(`${subIndent}${key}:`);
                    value.forEach(item => {
                        lines.push(`${subIndent}  - ${JSON.stringify(item)}`);
                    });
                } else if (typeof value === 'object') {
                    if (Object.keys(value).length === 0) continue;
                    lines.push(`${subIndent}${key}:`);
                    for (const subKey in value) {
                        lines.push(`${subIndent}  ${subKey}: ${JSON.stringify(value[subKey])}`);
                    }
                } else {
                    lines.push(`${subIndent}${key}: ${JSON.stringify(value)}`);
                }
            }
            return lines.join('\n');
        }

        function convert() {
            const lines = document.getElementById("input").value.trim().split("\n");
            const proxies = lines.map(line => line.trim()).filter(Boolean).map(parseLink).filter(Boolean);
            const full = document.getElementById("fullConfig").checked;
            let yamlString = "";

            if (full && proxies.length > 0) {
                const proxyNames = proxies.map(p => p.name);
                let finalYaml = "port: 7890\nsocks-port: 7891\nmode: rule\nallow-lan: true\nlog-level: info\n\nproxies:\n";
                proxies.forEach(p => {
                    finalYaml += `${proxyToExpandedYaml(p)}\n`;
                });
                finalYaml += "\nproxy-groups:\n";
                // [修改] 将组名改为 PROXY 以匹配新规则
                finalYaml += "  - name: PROXY\n    type: select\n    proxies:\n      - DIRECT\n";
                proxyNames.forEach(name => {
                    finalYaml += `      - "${name}"\n`;
                });

                // [修改] 替换为新的、更全面的规则集
                finalYaml += `
rule-providers:
  reject:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt"
    path: ./ruleset/reject.yaml
    interval: 86400
  icloud:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt"
    path: ./ruleset/icloud.yaml
    interval: 86400
  apple:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt"
    path: ./ruleset/apple.yaml
    interval: 86400
  google:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt"
    path: ./ruleset/google.yaml
    interval: 86400
  proxy:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt"
    path: ./ruleset/proxy.yaml
    interval: 86400
  direct:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt"
    path: ./ruleset/direct.yaml
    interval: 86400
  private:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt"
    path: ./ruleset/private.yaml
    interval: 86400
  gfw:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt"
    path: ./ruleset/gfw.yaml
    interval: 86400
  tld-not-cn:
    type: http
    behavior: domain
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt"
    path: ./ruleset/tld-not-cn.yaml
    interval: 86400
  telegramcidr:
    type: http
    behavior: ipcidr
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt"
    path: ./ruleset/telegramcidr.yaml
    interval: 86400
  cncidr:
    type: http
    behavior: ipcidr
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt"
    path: ./ruleset/cncidr.yaml
    interval: 86400
  lancidr:
    type: http
    behavior: ipcidr
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt"
    path: ./ruleset/lancidr.yaml
    interval: 86400
  applications:
    type: http
    behavior: classical
    url: "https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/applications.txt"
    path: ./ruleset/applications.yaml
    interval: 86400

rules:
  - RULE-SET,applications,DIRECT
  - DOMAIN,clash.razord.top,DIRECT
  - DOMAIN,yacd.haishan.me,DIRECT
  - RULE-SET,private,DIRECT
  - RULE-SET,reject,REJECT
  - RULE-SET,icloud,DIRECT
  - RULE-SET,apple,DIRECT
  - RULE-SET,google,PROXY
  - RULE-SET,proxy,PROXY
  - RULE-SET,direct,DIRECT
  - RULE-SET,lancidr,DIRECT
  - RULE-SET,cncidr,DIRECT
  - RULE-SET,telegramcidr,PROXY
  - GEOIP,LAN,DIRECT
  - GEOIP,CN,DIRECT
  - MATCH,PROXY
`;
                yamlString = finalYaml;
            } else {
                yamlString = "proxies:\n" + proxies.map(p => proxyToExpandedYaml(p)).join('\n');
            }
            document.getElementById("output").textContent = yamlString.trim();
        }
        function copyOutput() { const text = document.getElementById("output").textContent; if (!text.trim()) return; navigator.clipboard.writeText(text).then(() => alert("配置已复制")); }
        function downloadYaml() { const text = document.getElementById("output").textContent; if (!text.trim()) return; const blob = new Blob([text], { type: 'text/yaml' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'clash-meta-config.yaml'; a.click(); URL.revokeObjectURL(a.href); }
    </script>
</body>

</html>